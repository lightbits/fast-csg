.version 6.0
.target sm_60
.address_size 64

.func (.reg.f32 result) test1(.reg.f32 x, .reg.f32 y, .reg.f32 z)
{
    mul.ftz.f32 result, x, x;
    ret.uni;
}

// length((x,y,z)) - 0.5
.func (.reg.f32 result) test2(.reg.f32 x, .reg.f32 y, .reg.f32 z)
{
    mul.ftz.f32 result, x, x;         // result = x*x
    fma.rn.ftz.f32 result, y, y, result; // result = x*x + y*y
    fma.rn.ftz.f32 result, z, z, result; // result = x*x + y*y + z*z
    sqrt.approx.ftz.f32 result, result;
    add.ftz.f32 result, result, -0.5;
    ret;
}

// max(length((x,y,z)) - 0.5, abs(y) - 0.5)
.func (.reg.f32 result) test3(.reg.f32 x, .reg.f32 y, .reg.f32 z)
{
    mul.ftz.f32 result, x, x;         // result = x*x
    fma.rn.ftz.f32 result, y, y, result; // result = x*x + y*y
    fma.rn.ftz.f32 result, z, z, result; // result = x*x + y*y + z*z
    sqrt.approx.ftz.f32 result, result;
    add.ftz.f32 result, result, -0.5;
    .reg.f32 clip;
    abs.ftz.f32 clip, y;
    add.ftz.f32 clip, clip, -0.5;
    max.ftz.f32 result, result, clip;
    ret;
}

// max(box[w=1,h=1,d=1], -sphere[ty=1.0, r=0.5])
.func (.reg.f32 result) test4(.reg.f32 x, .reg.f32 y, .reg.f32 z)
{
    .reg.f32 f<3>;
    .reg.f32 d<2>;
    abs.ftz.f32 f0, x;
    abs.ftz.f32 f1, y;
    abs.ftz.f32 f2, z;
    add.ftz.f32 f0,f0, -1.0;
    add.ftz.f32 f1,f1, -1.0;
    add.ftz.f32 f2,f2, -1.0;
    max.ftz.f32 d0,f0,f1;
    max.ftz.f32 d0,d0,f2;
    add.ftz.f32 f0, y, -1.0;
    fma.ftz.rn.f32 d1, x, x, 0.0;
    fma.ftz.rn.f32 d1, f0, f0, d1;
    fma.ftz.rn.f32 d1, z, z, d1;
    sqrt.approx.ftz.f32 d1, d1;
    add.ftz.f32 d1, d1, -0.5;
    neg.ftz.f32 d1, d1;
    max.ftz.f32 result,d0,d1;
    ret;
}

.visible .entry test(.param.u64 input_address, .param.u64 output_address)
{
    .reg .f32   x,y,z,w;
    .reg .b32   %r<5>;
    .reg .b64   %rd<9>;
    .reg.f32 result;

    ld.param.u64        %rd1, [input_address];
    ld.param.u64        %rd2, [output_address];
    cvta.to.global.u64  %rd3, %rd2;
    cvta.to.global.u64  %rd4, %rd1;
    mov.u32             %r1, %tid.x;        // threadIdx.x
    mov.u32             %r2, %ctaid.x;      // blockIdx.x
    mov.u32             %r3, %ntid.x;       // blockDim.x
    mad.lo.s32          %r4, %r3, %r2, %r1; // blockDim.x*blockIdx.x + threadIdx.x
    mul.wide.s32        %rd5, %r4, 16;      // sizeof(float)*4*(blockDim.x*blockIdx.x + threadIdx.x)
    add.s64             %rd6, %rd4, %rd5;   // input_address_global + sizeof(float)*4*(...)
    mul.wide.s32        %rd7, %r4, 4;       // sizeof(float)*1*(blockDim.x*blockIdx.x + threadIdx.)
    add.s64             %rd8, %rd3, %rd7;   // output_address_global + sizeof(float)*1*(...)
    ld.global.v4.f32    {x, y, z, w}, [%rd6];

    call.uni (result), test1, (x,y,z);
    st.global.f32 [%rd8], result;

    call.uni (result), test2, (x,y,z);
    st.global.f32 [%rd8 + 16384], result;

    call.uni (result), test3, (x,y,z);
    st.global.f32 [%rd8 + 32768], result;

    call.uni (result), test4, (x,y,z);
    st.global.f32 [%rd8 + 49152], result;
}
